import {
  useCallback
} from 'react';

import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

/**
 * Generated by orval v7.8.0 ðŸº
 * Do not edit manually.
 * Authorizer
 * Authorizer service
 * OpenAPI spec version: v0.20.10
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';

import type {
  PoliciesGetParams,
  PoliciesListParams,
  RpcStatus,
  V2CompileRequest,
  V2CompileResponse,
  V2DecisionTreeRequest,
  V2DecisionTreeResponse,
  V2GetPolicyResponse,
  V2InfoResponse,
  V2IsRequest,
  V2IsResponse,
  V2ListPoliciesResponse,
  V2QueryRequest,
  V2QueryResponse
} from '../../types/authorizer';

import { useAuthorizerClient } from '../clients/rest';




/**
 * Executes a partial query on the loaded policy runtime.
 * @summary Compile
 */
export const useAuthorizerCompileHook = () => {
        const authorizerCompile = useAuthorizerClient<V2CompileResponse>();

        return useCallback((
    v2CompileRequest: V2CompileRequest,
 signal?: AbortSignal
) => {
        return authorizerCompile(
          {data: v2CompileRequest, headers: {'Content-Type': 'application/json', },
      method: 'POST',
      signal, url: `/api/v2/authz/compile`
    },
          );
        }, [authorizerCompile])
      }
    


export const useAuthorizerCompileMutationOptions = <TError = RpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useAuthorizerCompileHook>>>, TError,{data: V2CompileRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useAuthorizerCompileHook>>>, TError,{data: V2CompileRequest}, TContext> => {
    
const mutationKey = ['authorizerCompile'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      const authorizerCompile =  useAuthorizerCompileHook()


      const mutationFn: MutationFunction<Awaited<ReturnType<ReturnType<typeof useAuthorizerCompileHook>>>, {data: V2CompileRequest}> = (props) => {
          const {data} = props ?? {};

          return  authorizerCompile(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthorizerCompileMutationBody = V2CompileRequest
    export type AuthorizerCompileMutationError = RpcStatus
    export type AuthorizerCompileMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useAuthorizerCompileHook>>>>

    /**
 * @summary Compile
 */
export const useAuthorizerCompile = <TError = RpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useAuthorizerCompileHook>>>, TError,{data: V2CompileRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<ReturnType<typeof useAuthorizerCompileHook>>>,
        TError,
        {data: V2CompileRequest},
        TContext
      > => {

      const mutationOptions = useAuthorizerCompileMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Returns decision tree for given identity context.
 * @summary Decision tree
 */
export const useAuthorizerDecisionTreeHook = () => {
        const authorizerDecisionTree = useAuthorizerClient<V2DecisionTreeResponse>();

        return useCallback((
    v2DecisionTreeRequest: V2DecisionTreeRequest,
 signal?: AbortSignal
) => {
        return authorizerDecisionTree(
          {data: v2DecisionTreeRequest, headers: {'Content-Type': 'application/json', },
      method: 'POST',
      signal, url: `/api/v2/authz/decisiontree`
    },
          );
        }, [authorizerDecisionTree])
      }
    


export const useAuthorizerDecisionTreeMutationOptions = <TError = RpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useAuthorizerDecisionTreeHook>>>, TError,{data: V2DecisionTreeRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useAuthorizerDecisionTreeHook>>>, TError,{data: V2DecisionTreeRequest}, TContext> => {
    
const mutationKey = ['authorizerDecisionTree'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      const authorizerDecisionTree =  useAuthorizerDecisionTreeHook()


      const mutationFn: MutationFunction<Awaited<ReturnType<ReturnType<typeof useAuthorizerDecisionTreeHook>>>, {data: V2DecisionTreeRequest}> = (props) => {
          const {data} = props ?? {};

          return  authorizerDecisionTree(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthorizerDecisionTreeMutationBody = V2DecisionTreeRequest
    export type AuthorizerDecisionTreeMutationError = RpcStatus
    export type AuthorizerDecisionTreeMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useAuthorizerDecisionTreeHook>>>>

    /**
 * @summary Decision tree
 */
export const useAuthorizerDecisionTree = <TError = RpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useAuthorizerDecisionTreeHook>>>, TError,{data: V2DecisionTreeRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<ReturnType<typeof useAuthorizerDecisionTreeHook>>>,
        TError,
        {data: V2DecisionTreeRequest},
        TContext
      > => {

      const mutationOptions = useAuthorizerDecisionTreeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Determines if identity context is authorized to access the resource guarded by the given policy.
 * @summary Is (authorized)
 */
export const useAuthorizerIsHook = () => {
        const authorizerIs = useAuthorizerClient<V2IsResponse>();

        return useCallback((
    v2IsRequest: V2IsRequest,
 signal?: AbortSignal
) => {
        return authorizerIs(
          {data: v2IsRequest, headers: {'Content-Type': 'application/json', },
      method: 'POST',
      signal, url: `/api/v2/authz/is`
    },
          );
        }, [authorizerIs])
      }
    


export const useAuthorizerIsMutationOptions = <TError = RpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useAuthorizerIsHook>>>, TError,{data: V2IsRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useAuthorizerIsHook>>>, TError,{data: V2IsRequest}, TContext> => {
    
const mutationKey = ['authorizerIs'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      const authorizerIs =  useAuthorizerIsHook()


      const mutationFn: MutationFunction<Awaited<ReturnType<ReturnType<typeof useAuthorizerIsHook>>>, {data: V2IsRequest}> = (props) => {
          const {data} = props ?? {};

          return  authorizerIs(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthorizerIsMutationBody = V2IsRequest
    export type AuthorizerIsMutationError = RpcStatus
    export type AuthorizerIsMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useAuthorizerIsHook>>>>

    /**
 * @summary Is (authorized)
 */
export const useAuthorizerIs = <TError = RpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useAuthorizerIsHook>>>, TError,{data: V2IsRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<ReturnType<typeof useAuthorizerIsHook>>>,
        TError,
        {data: V2IsRequest},
        TContext
      > => {

      const mutationOptions = useAuthorizerIsMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Executes a rego query on the loaded policy runtime.
 * @summary Query
 */
export const useAuthorizerQueryHook = () => {
        const authorizerQuery = useAuthorizerClient<V2QueryResponse>();

        return useCallback((
    v2QueryRequest: V2QueryRequest,
 signal?: AbortSignal
) => {
        return authorizerQuery(
          {data: v2QueryRequest, headers: {'Content-Type': 'application/json', },
      method: 'POST',
      signal, url: `/api/v2/authz/query`
    },
          );
        }, [authorizerQuery])
      }
    


export const useAuthorizerQueryMutationOptions = <TError = RpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useAuthorizerQueryHook>>>, TError,{data: V2QueryRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useAuthorizerQueryHook>>>, TError,{data: V2QueryRequest}, TContext> => {
    
const mutationKey = ['authorizerQuery'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      const authorizerQuery =  useAuthorizerQueryHook()


      const mutationFn: MutationFunction<Awaited<ReturnType<ReturnType<typeof useAuthorizerQueryHook>>>, {data: V2QueryRequest}> = (props) => {
          const {data} = props ?? {};

          return  authorizerQuery(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthorizerQueryMutationBody = V2QueryRequest
    export type AuthorizerQueryMutationError = RpcStatus
    export type AuthorizerQueryMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useAuthorizerQueryHook>>>>

    /**
 * @summary Query
 */
export const useAuthorizerQuery = <TError = RpcStatus,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useAuthorizerQueryHook>>>, TError,{data: V2QueryRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<ReturnType<typeof useAuthorizerQueryHook>>>,
        TError,
        {data: V2QueryRequest},
        TContext
      > => {

      const mutationOptions = useAuthorizerQueryMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Return version information.
 * @summary Info
 */
export const useInfoGetHook = () => {
        const infoGet = useAuthorizerClient<V2InfoResponse>();

        return useCallback((
    
 signal?: AbortSignal
) => {
        return infoGet(
          {method: 'GET', signal, url: `/api/v2/info`
    },
          );
        }, [infoGet])
      }
    

export const getInfoGetQueryKey = () => {
    return [`/api/v2/info`] as const;
    }

    
export const useInfoGetQueryOptions = <TData = Awaited<ReturnType<ReturnType<typeof useInfoGetHook>>>, TError = RpcStatus>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useInfoGetHook>>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInfoGetQueryKey();

  const infoGet =  useInfoGetHook();

    const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useInfoGetHook>>>> = ({ signal }) => infoGet(signal);

      

      

   return  { queryFn, queryKey, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useInfoGetHook>>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type InfoGetQueryError = RpcStatus
export type InfoGetQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useInfoGetHook>>>>


export function useInfoGet<TData = Awaited<ReturnType<ReturnType<typeof useInfoGetHook>>>, TError = RpcStatus>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useInfoGetHook>>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<ReturnType<typeof useInfoGetHook>>>,
          TError,
          Awaited<ReturnType<ReturnType<typeof useInfoGetHook>>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInfoGet<TData = Awaited<ReturnType<ReturnType<typeof useInfoGetHook>>>, TError = RpcStatus>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useInfoGetHook>>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<ReturnType<typeof useInfoGetHook>>>,
          TError,
          Awaited<ReturnType<ReturnType<typeof useInfoGetHook>>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInfoGet<TData = Awaited<ReturnType<ReturnType<typeof useInfoGetHook>>>, TError = RpcStatus>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useInfoGetHook>>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Info
 */

export function useInfoGet<TData = Awaited<ReturnType<ReturnType<typeof useInfoGetHook>>>, TError = RpcStatus>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useInfoGetHook>>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = useInfoGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Lists the policy modules for the policy bundle.
 * @summary List Policies
 */
export const usePoliciesListHook = () => {
        const policiesList = useAuthorizerClient<V2ListPoliciesResponse>();

        return useCallback((
    params?: PoliciesListParams,
 signal?: AbortSignal
) => {
        return policiesList(
          {method: 'GET', params,
        signal, url: `/api/v2/policies`
    },
          );
        }, [policiesList])
      }
    

export const getPoliciesListQueryKey = (params?: PoliciesListParams,) => {
    return [`/api/v2/policies`, ...(params ? [params]: [])] as const;
    }

    
export const usePoliciesListQueryOptions = <TData = Awaited<ReturnType<ReturnType<typeof usePoliciesListHook>>>, TError = RpcStatus>(params?: PoliciesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof usePoliciesListHook>>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPoliciesListQueryKey(params);

  const policiesList =  usePoliciesListHook();

    const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof usePoliciesListHook>>>> = ({ signal }) => policiesList(params, signal);

      

      

   return  { queryFn, queryKey, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<ReturnType<typeof usePoliciesListHook>>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PoliciesListQueryError = RpcStatus
export type PoliciesListQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof usePoliciesListHook>>>>


export function usePoliciesList<TData = Awaited<ReturnType<ReturnType<typeof usePoliciesListHook>>>, TError = RpcStatus>(
 params: PoliciesListParams |  undefined, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof usePoliciesListHook>>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<ReturnType<typeof usePoliciesListHook>>>,
          TError,
          Awaited<ReturnType<ReturnType<typeof usePoliciesListHook>>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePoliciesList<TData = Awaited<ReturnType<ReturnType<typeof usePoliciesListHook>>>, TError = RpcStatus>(
 params?: PoliciesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof usePoliciesListHook>>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<ReturnType<typeof usePoliciesListHook>>>,
          TError,
          Awaited<ReturnType<ReturnType<typeof usePoliciesListHook>>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePoliciesList<TData = Awaited<ReturnType<ReturnType<typeof usePoliciesListHook>>>, TError = RpcStatus>(
 params?: PoliciesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof usePoliciesListHook>>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Policies
 */

export function usePoliciesList<TData = Awaited<ReturnType<ReturnType<typeof usePoliciesListHook>>>, TError = RpcStatus>(
 params?: PoliciesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof usePoliciesListHook>>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = usePoliciesListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Gets the policy modules for the given module Id.
 * @summary Get Policy
 */
export const usePoliciesGetHook = () => {
        const policiesGet = useAuthorizerClient<V2GetPolicyResponse>();

        return useCallback((
    id: string,
    params?: PoliciesGetParams,
 signal?: AbortSignal
) => {
        return policiesGet(
          {method: 'GET', params,
        signal, url: `/api/v2/policies/${id}`
    },
          );
        }, [policiesGet])
      }
    

export const getPoliciesGetQueryKey = (id: string,
    params?: PoliciesGetParams,) => {
    return [`/api/v2/policies/${id}`, ...(params ? [params]: [])] as const;
    }

    
export const usePoliciesGetQueryOptions = <TData = Awaited<ReturnType<ReturnType<typeof usePoliciesGetHook>>>, TError = RpcStatus>(id: string,
    params?: PoliciesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof usePoliciesGetHook>>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPoliciesGetQueryKey(id,params);

  const policiesGet =  usePoliciesGetHook();

    const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof usePoliciesGetHook>>>> = ({ signal }) => policiesGet(id,params, signal);

      

      

   return  { enabled: !!(id), queryFn, queryKey, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<ReturnType<typeof usePoliciesGetHook>>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PoliciesGetQueryError = RpcStatus
export type PoliciesGetQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof usePoliciesGetHook>>>>


export function usePoliciesGet<TData = Awaited<ReturnType<ReturnType<typeof usePoliciesGetHook>>>, TError = RpcStatus>(
 id: string,
    params: PoliciesGetParams |  undefined, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof usePoliciesGetHook>>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<ReturnType<typeof usePoliciesGetHook>>>,
          TError,
          Awaited<ReturnType<ReturnType<typeof usePoliciesGetHook>>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePoliciesGet<TData = Awaited<ReturnType<ReturnType<typeof usePoliciesGetHook>>>, TError = RpcStatus>(
 id: string,
    params?: PoliciesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof usePoliciesGetHook>>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<ReturnType<typeof usePoliciesGetHook>>>,
          TError,
          Awaited<ReturnType<ReturnType<typeof usePoliciesGetHook>>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePoliciesGet<TData = Awaited<ReturnType<ReturnType<typeof usePoliciesGetHook>>>, TError = RpcStatus>(
 id: string,
    params?: PoliciesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof usePoliciesGetHook>>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Policy
 */

export function usePoliciesGet<TData = Awaited<ReturnType<ReturnType<typeof usePoliciesGetHook>>>, TError = RpcStatus>(
 id: string,
    params?: PoliciesGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof usePoliciesGetHook>>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = usePoliciesGetQueryOptions(id,params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




